#!/usr/bin/env python3
"""
Changelog Parser

Parses docs/CHANGELOG.md and generates web/src/data/changelogData.ts
with structured version entries for the web frontend.

Usage:
    python scripts/generate_changelog.py
"""

import re
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Optional
from dataclasses import dataclass, field


# Repository root (parent of scripts/)
REPO_ROOT = Path(__file__).parent.parent
CHANGELOG_FILE = REPO_ROOT / "docs" / "CHANGELOG.md"
OUTPUT_FILE = REPO_ROOT / "web" / "src" / "data" / "changelogData.ts"


@dataclass
class ChangeItem:
    """A single change bullet point."""
    text: str
    details: List[str] = field(default_factory=list)


@dataclass
class ChangeSection:
    """A section within a version (Added, Changed, Fixed, etc.)."""
    type: str  # 'added', 'changed', 'fixed', 'technical', 'developer-notes'
    items: List[ChangeItem] = field(default_factory=list)


@dataclass
class VersionEntry:
    """A single version release."""
    version: str
    date: str
    title: str
    sections: List[ChangeSection] = field(default_factory=list)


def parse_changelog(content: str) -> List[VersionEntry]:
    """Parse changelog markdown into structured data."""
    entries: List[VersionEntry] = []

    # Split into version blocks
    # Pattern: ## [version] - date - title  OR  ## [version] - date
    version_pattern = re.compile(
        r'^## \[([^\]]+)\] - (\d{4}-\d{2}-\d{2})(?: - (.+))?$',
        re.MULTILINE
    )

    matches = list(version_pattern.finditer(content))

    for i, match in enumerate(matches):
        version = match.group(1)
        date = match.group(2)
        title = match.group(3) or ''

        # Get content between this version and next (or end)
        start = match.end()
        end = matches[i + 1].start() if i + 1 < len(matches) else len(content)
        block = content[start:end].strip()

        # Parse sections within this version
        sections = parse_sections(block)

        entries.append(VersionEntry(
            version=version,
            date=date,
            title=title,
            sections=sections
        ))

    return entries


def parse_sections(block: str) -> List[ChangeSection]:
    """Parse sections (Added, Changed, etc.) from a version block."""
    sections: List[ChangeSection] = []

    # Section pattern: ### SectionName
    section_pattern = re.compile(r'^### (\w+(?:[- ]\w+)?)', re.MULTILINE)
    matches = list(section_pattern.finditer(block))

    for i, match in enumerate(matches):
        section_type = match.group(1).lower().replace(' ', '-')

        # Get content between this section and next (or end)
        start = match.end()
        end = matches[i + 1].start() if i + 1 < len(matches) else len(block)
        section_content = block[start:end].strip()

        # Parse items in this section
        items = parse_items(section_content)

        if items:
            sections.append(ChangeSection(
                type=section_type,
                items=items
            ))

    return sections


def parse_items(section_content: str) -> List[ChangeItem]:
    """Parse bullet items from a section."""
    items: List[ChangeItem] = []
    lines = section_content.split('\n')

    current_item: Optional[ChangeItem] = None

    for line in lines:
        # Top-level bullet: - **Feature**: Description
        if line.startswith('- '):
            if current_item:
                items.append(current_item)

            text = line[2:].strip()
            current_item = ChangeItem(text=text, details=[])

        # Sub-bullet (detail): starts with spaces then -
        elif re.match(r'^  +- ', line):
            if current_item:
                detail = re.sub(r'^  +- ', '', line).strip()
                current_item.details.append(detail)

        # Code block or continuation - treat as detail
        elif line.startswith('```') or (current_item and line.startswith('  ')):
            if current_item and line.strip():
                current_item.details.append(line.strip())

    if current_item:
        items.append(current_item)

    return items


def escape_string(s: str) -> str:
    """Escape a string for TypeScript."""
    return s.replace('\\', '\\\\').replace("'", "\\'").replace('\n', '\\n')


def generate_typescript(entries: List[VersionEntry]) -> str:
    """Generate TypeScript data file content."""
    timestamp = datetime.now().isoformat()

    lines = [
        '/**',
        ' * Changelog Data',
        ' * Auto-generated by scripts/generate_changelog.py',
        f' * Generated: {timestamp}',
        ' *',
        ' * DO NOT EDIT MANUALLY - Edit docs/CHANGELOG.md and run the script',
        ' */',
        '',
        '// =============================================================================',
        '// Types',
        '// =============================================================================',
        '',
        "export type SectionType = 'added' | 'changed' | 'fixed' | 'technical' | 'developer-notes' | 'key-guarantee';",
        '',
        'export interface ChangeItem {',
        '  text: string;',
        '  details: string[];',
        '}',
        '',
        'export interface ChangeSection {',
        '  type: SectionType;',
        '  items: ChangeItem[];',
        '}',
        '',
        'export interface VersionEntry {',
        '  version: string;',
        '  date: string;',
        '  title: string;',
        '  sections: ChangeSection[];',
        '}',
        '',
        '// =============================================================================',
        '// Config',
        '// =============================================================================',
        '',
        'export const SECTION_CONFIG: Record<SectionType, { label: string; icon: string; color: string }> = {',
        "  added: { label: 'Added', icon: '+', color: '#22c55e' },",
        "  changed: { label: 'Changed', icon: '~', color: '#f59e0b' },",
        "  fixed: { label: 'Fixed', icon: '!', color: '#3b82f6' },",
        "  technical: { label: 'Technical', icon: '#', color: '#8b5cf6' },",
        "  'developer-notes': { label: 'Developer Notes', icon: '>', color: '#64748b' },",
        "  'key-guarantee': { label: 'Key Guarantee', icon: '*', color: '#06b6d4' },",
        '};',
        '',
        f"export const GENERATED_AT = '{timestamp}';",
        '',
        '// =============================================================================',
        '// Data',
        '// =============================================================================',
        '',
        'export const CHANGELOG_ENTRIES: VersionEntry[] = [',
    ]

    for entry in entries:
        lines.append('  {')
        lines.append(f"    version: '{escape_string(entry.version)}',")
        lines.append(f"    date: '{entry.date}',")
        lines.append(f"    title: '{escape_string(entry.title)}',")
        lines.append('    sections: [')

        for section in entry.sections:
            lines.append('      {')
            lines.append(f"        type: '{section.type}',")
            lines.append('        items: [')

            for item in section.items:
                lines.append('          {')
                lines.append(f"            text: '{escape_string(item.text)}',")
                if item.details:
                    lines.append('            details: [')
                    for detail in item.details:
                        lines.append(f"              '{escape_string(detail)}',")
                    lines.append('            ],')
                else:
                    lines.append('            details: [],')
                lines.append('          },')

            lines.append('        ],')
            lines.append('      },')

        lines.append('    ],')
        lines.append('  },')

    lines.append('];')
    lines.append('')
    lines.append('// =============================================================================')
    lines.append('// Helper Functions')
    lines.append('// =============================================================================')
    lines.append('')
    lines.append('export function getLatestVersion(): VersionEntry | undefined {')
    lines.append('  return CHANGELOG_ENTRIES[0];')
    lines.append('}')
    lines.append('')
    lines.append('export function getVersionByNumber(version: string): VersionEntry | undefined {')
    lines.append('  return CHANGELOG_ENTRIES.find(e => e.version === version);')
    lines.append('}')
    lines.append('')
    lines.append('export function getMajorVersions(): VersionEntry[] {')
    lines.append("  return CHANGELOG_ENTRIES.filter(e => e.version.endsWith('.0.0') || e.version.endsWith('.0'));")
    lines.append('}')
    lines.append('')
    lines.append('export function getVersionCount(): number {')
    lines.append('  return CHANGELOG_ENTRIES.length;')
    lines.append('}')
    lines.append('')
    lines.append('export function getDateRange(): { earliest: string; latest: string } {')
    lines.append('  const dates = CHANGELOG_ENTRIES.map(e => e.date).sort();')
    lines.append('  return {')
    lines.append('    earliest: dates[0] || "",')
    lines.append('    latest: dates[dates.length - 1] || "",')
    lines.append('  };')
    lines.append('}')
    lines.append('')

    return '\n'.join(lines)


def main():
    """Main entry point."""
    print(f"Reading {CHANGELOG_FILE}...")

    if not CHANGELOG_FILE.exists():
        print(f"Error: {CHANGELOG_FILE} not found")
        return 1

    content = CHANGELOG_FILE.read_text(encoding='utf-8')

    print("Parsing changelog...")
    entries = parse_changelog(content)

    print(f"Found {len(entries)} version entries")

    # Show summary
    if entries:
        print(f"  Latest: {entries[0].version} ({entries[0].date})")
        print(f"  Oldest: {entries[-1].version} ({entries[-1].date})")

    print(f"\nGenerating {OUTPUT_FILE}...")
    typescript = generate_typescript(entries)

    # Ensure output directory exists
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)

    OUTPUT_FILE.write_text(typescript, encoding='utf-8')

    print(f"Done! Generated {len(typescript)} bytes")
    return 0


if __name__ == '__main__':
    exit(main())
